{"./":{"url":"./","title":"PLUGChain","keywords":"","body":"PLUGChain简介 p{text-indent:2em;} 互联网早已成为了人们生活中必不可少的工具，许多人早已经习惯于从互联网获取所需要的知识，不论是准确的或是虚假的。而且大部分情况下我们不会去判别互联网带给我们的知识的真实性，也不会去主动去梳理杂乱的知识灌输。全世界的数据传输已经非常的方便，与此同时虚假的消息也保持了极高的传播速度。如今，人们亟需在纷乱的互联网世界中快速的获取真实数据，同样的在区块链的世界亦是如此。 区块链行业已经经过多年的发展，如今从金融、产品溯源、政务、民生扩展到智慧城市建设等方面，技术应用场景不断深入化和多元化，已经和大众息息相关了。但是现有所有应用链都存在着一个致命的问题——无法和真实世界进行可信的数据互通。而将应用链与外部系统打通，推动区块链技术应用场景真实落地的工具，就是Oracle Network Protocol预言机。 在区块链的悬浮半空、预言机的数据跨链交互、公链的实体商业场景应用多重需求下，PLUG 研发团队致力于构建一条能够在区块链与区块链、区块链与现实世界之间，实现无感交互的高性能公链，也就是 PLUGChain。 PLUGChain 是 Cosmos Hub 的 Cosmos SDK 应用程序的名称。 它带有 1 个主要入口点： plugchaind 守护进程和命令行界面 (CLI)。 运行 plugchain 应用程序的全节点。 plugchain 使用以下模块构建在 Cosmos SDK 上： x/auth：帐户和签名。 x/bank：代币转账。 x/staking：Staking 逻辑。 x/mint：通货膨胀逻辑。 x/distribution：费用分配逻辑。 x/slashing：削减逻辑。 x/gov：治理逻辑。 ibc-go/modules：区块链间通信。 托管在 cosmos/ibc-go 存储库中。 x/params：处理应用级参数。 x/token: 代币逻辑。开发中 x/dex: 自动化做市商。托管在 tendermint/liquidity 存储库中。 接下来，学习如何安装 plugchain。 "},"cn/installation.html":{"url":"cn/installation.html","title":"开始","keywords":"","body":"INSTALL plugchain 本指南将安装plugchaind入口点到系统上，您可以作为完整节点或验证者加入 安装依赖 centos系统示例如下: yum install make gcc git install Golang golang 安装(>=1.16) golang各种版本下载 本教程下载的v1.16.4版本,官方安装golang教程docs wget https://studygolang.com/dl/golang/go1.16.4.linux-amd64.tar.gz rm -rf /usr/local/go && tar -C /usr/local -zxf go1.16.4.linux-amd64.tar.gz export PATH=$PATH:/usr/local/go/bin mkdir -p $HOME/go/bin echo \"export PATH=$PATH:$(go env GOPATH)/bin\" >> ~/.bash_profile echo \"export GOPATH=$HOME/go\" >> ~/.bash_profile source ~/.bash_profile go version 在Windows下，你可以通过\"系统\"控制面板的\"高级\"选项卡上的\"环境变量\"按钮设置环境变量(HOME或GO111MODULE)。一些版本的Windows通过\"系统\"控制面板中的\"高级系统设置\"选项提供了这个控制面板。 安装最新版的plugchain,从仓库clone代码 git clone https://github.com/oracleNetworkProtocol/plugchain.git 如果克隆仓库比较慢或者没反应的情况，可以把克隆地址 github.com 换成国内镜像，已知的国内镜像有github.com.cnpmjs.org和git.sdut.me/ 开启gomodule和设置终端GOPROXY go env -w GO111MODULE=on export GOPROXY=https://goproxy.io,direct 下一步 make install 如果包下载超时，可以选择更换下代理，export GOPROXY=https://goproxy.cn,direct 编译二进制文件 cd plugchain && make install (可选)默认编译主分支代码，可选择固定版本编译，例如: cd plugchaind && git checkout v0.3.0 && make install 安装完成之后，会有plugchaind二进制文件，可以验证下是否生效 plugchaind version 输出内容示例如下 v0.3.0 完成 plugchaind 安装，就可以选择加入主网或者测试网了。 加入主网 加入测试网 "},"cn/mainnet.html":{"url":"cn/mainnet.html","title":"加入到 PLUGChain 主网","keywords":"","body":"PlugChain 主网 [!Info]: 加入主网步骤 安装plugchaind 初始化数据目录 替换数据目录的genesis.json创世文件，添加种子连接信息 启动节点,同步区块 加入主网 根据教程确认plugchaind命令已成功安装 使用 plugchaind init 初始化数据目录，chain-id 设置为 plugchain plugchaind init myNode --chain-id plugchain 主网创世文件和种子信息 下载https://github.com/oracleNetworkProtocol/plugchain/blob/main/mainnet/v1/genesis.json替换 --home 目录下的config/genesis.json //--home 默认目录为~/.plugchain 复制 https://github.com/oracleNetworkProtocol/plugchain/blob/main/mainnet/v1/seeds.txt 文件中提供的 seeds 修改--home目录下的 config/config.toml 中的seeds参数以设置链接的种子节点 修改完之后，使用 plugchaind start --minimum-gas-prices 0.0001plug 启动节点 "},"cn/testnet.html":{"url":"cn/testnet.html","title":"加入到 PLUGChain 测试网","keywords":"","body":"PlugChain 测试网 测试网现在处于活动状态，以下是一些重要的详细信息： 手动加入测试网 根据教程确认plugchaind命令已成功安装 plugchaind init 时 chain-id 设置为 plugchain-testnet-1 下载https://github.com/oracleNetworkProtocol/plugchain/blob/main/testnet/latest/genesis.json替换 --home 目录下的config/genesis.json //--home 默认目录为~/.plugchain 根据 testnet/latest 目录中提供的 seeds 修改--home目录下的 config/config.toml 中的seeds参数以设置链接的种子节点 修改完之后，使用 plugchaind start --minimum-gas-prices 0.0001line 启动节点 脚本安装并加入测试网： 根据 testnet/latest 目录中提供的 seeds 修改 testnet/scripts/testnet-val-setup.sh 脚本中的SEEDS参数 运行testnet/scripts/testnet-val-setup.sh脚本 testnet目录 cd testnet/scripts && chmod +x testnet-val-setup.sh ./testnet-val-setup.sh "},"cn/testnet-process.html":{"url":"cn/testnet-process.html","title":"测试网 测试流程 ","keywords":"","body":"测试网目前需要操作步骤 节点搭建，同步测试网 搭建文档 成为验证者，会在验证者页面出现自己的节点 在终端或者浏览器委托line币到自己的节点，查看节点信息等操作 查看终端各个命令的用处和使用方式 开通自己节点的对外api服务,文档 关于不同节点的配置，请移步节点知识，配置修改：验证者的配置需要成为验证者之后修改，种子和哨兵的配置可以直接修改，重启即可成为此身份 [!warning] 切记，保存好自己创建的地址的助记词，如下信息中的：pride cricket area future day trust pattern exhaust orange mouse chronic game make tobacco paddle float tuition vocal shove tag gas cargo idea label一串字母 - name: testwallet type: local address: gx1fp5qd7ztst597qzfyhcmxf0jlrdddex53s2837 pubkey: gxpub1addwnpepqvmancaq7l52sshz4k09y9v7ftlt2cdaqgwpml4x2kga7xvspcrjq8z496t mnemonic: \"\" threshold: 0 pubkeys: [] **Important** write this mnemonic phrase in a safe place. It is the only way to recover your account if you ever forget your password. pride cricket area future day trust pattern exhaust orange mouse chronic game make tobacco paddle float tuition vocal shove tag gas cargo idea label 相关知识点 节点 在线节点总质押量超过区块总质押量的2/3才出块 种子节点，需要修改参数seed_mode 为true ，当作为种子发现节点时，内网通信需要修改（config.toml） p2p的 laddr 为本机当时ip 自己的节点想共享出去，需要把公网ip写入external_address 参数里 手续费 区块链小数位数为1000000，在链上都是乘1000000 app.toml 节点运行需要设置最低手续费防止垃圾邮件 ，minimum-gas-prices = \"0.0001plug\" 手续费= (gas-prices * gas)或者 fees fees/1000000 为真正扣除手续费 验证者 config.toml文件， 验证者：double_sign_check_height = 0 参数：表示验证者断开区块链重新加入之后向上验证的块数，0表示不验证断开期间的块，其余正整数表示向上验证几个区块，当此数字大于期间出的块数时，会宕机连不上区块，等待断开期间出块数大于等于此值才可连上 create-validator， 字段 --commission-max-change-rate --commission-max-rate 设置之后不准修改，谨慎设置 edit-validator， 修改验证者信息时，各字段修改间隔24小时，min-self-delegation 不可减小，只能增加 质押限制 质押,取消质押: 取消质押币需要冻结21天后到账 转质押: 转质押后新节点对用户的转质押操作锁仓21天(质押,取消质押不受影响) 转质押一月可以操作7次 收益: 收益需要提取才能到可操作账户 进行质押,取消质押,转质押操作时自动提取收益 测试期间有问题可以总结起来,提交给技术部，共同维护plugchain "},"cn/problem.html":{"url":"cn/problem.html","title":"PLUGChain常见问题","keywords":"","body":"常见问题 genesis文件 请注意，所有持续时间均以纳秒为单位。 mint模块参数 ，出块造币（mint_denom:onp）数量 = total（mint_denom:onp币种的发行总量） / blocks_per_year（年出块数量） * inflation_rate_change(膨胀率) 开发问题 节点 在线节点总质押量超过区块总质押量的2/3才出块 自己的节点想共享出去，需要把公网ip写入external_address 参数里 例如： \"tcp://x.x.x.x:26656\" 手续费 区块链小数位数为1000000，在链上都是乘1000000 app.toml 节点运行需要设置最低手续费防止垃圾邮件 ，minimum-gas-prices 手续费= (gas-prices * gas )或者 fees gas 默认值 200000 fees/1000000 为真正扣除手续费 验证者 config.toml文件， 验证者：double_sign_check_height = 0 参数：表示验证者断开区块链重新加入之后向上验证的块数，0表示不验证断开期间的块，其余正整数表示向上验证几个区块，当此数字大于期间出的块数时，会宕机连不上区块，等待断开期间出块数大于等于此值才可连上 create-validator， 字段 --commission-max-change-rate --commission-max-rate 设置之后不准修改，谨慎设置 edit-validator， 修改验证者信息时，各字段修改间隔24小时，min-self-delegation 不可减小，只能增加 质押问题 质押,取消质押: 取消质押币需要冻结21天后到账 转质押: 转质押后新节点对用户的转质押操作锁仓21天(质押,取消质押不受影响) 转质押一月可以操作7次 收益: 收益需要提取才能到可操作账户 进行质押,取消质押,转质押操作时自动提取收益 "},"cn/node/":{"url":"cn/node/","title":"节点知识","keywords":"","body":"节点类型 全节点 全节点是参与网络但无助于保护网络的节点。完整节点可用于存储区块链的整个状态。Tendermint 有两种形式的状态。首先是区块链状态，这代表区块链的区块。其次是Application状态，它代表事务修改的状态。交易如何修改状态的知识不是由 Tendermint 掌握的，而是由 ABCI 边界另一侧的应用程序掌握的。 作为全节点运营商，您正在为网络提供服务，帮助其达成共识，并帮助其他人赶上当前区块。即使完整节点只能帮助网络达成共识，但保护您的节点免受对抗性参与者的侵害也很重要。如果可能，我们建议使用防火墙和代理。运行一个完整的节点可能很容易，但它因网络而异。在运行节点之前验证您的应用程序文档。 验证者节点 验证器是参与网络安全的节点。验证者在 Tendermint 中拥有相关的权力，这种权力可以代表权益证明系统中的权益、权威证明中的声誉或任何类型的可衡量单位。运行安全且一致的在线验证器对于网络健康至关重要。验证器必须安全且容错，建议使用 2 个或更多哨兵节点运行验证器。 验证器节点应该有 per=false，这样它就不会影响整个网络。持久对等点将成为您的哨兵节点。由于验证器没有试图隐藏它与谁通信，所以可以将私有对等点留空。设置无条件对等点对于验证器是可选的，因为它们没有完整的地址簿。 作为验证者，您有可能减轻体重，这是由应用程序定义的。如果验证者应该增加或减少权重，应用程序会通知 Tendermint。应用程序具有不同类型的恶意行为，导致验证者权力的削减。请检查您将运行的应用程序的文档以找到更多信息。 哨兵节点 哨兵节点几乎在所有方面都类似于完整节点。不同之处在于哨兵节点将拥有一个或多个私有节点。这些对等点可能是验证者或网络中的其他完整节点。哨兵节点旨在为您的验证器提供一层安全性，类似于防火墙与计算机的工作方式。 种子节点 种子节点为节点提供节点可以连接到的对等点列表。启动节点时，您必须至少提供一种类型的节点才能连接到所需的网络。通过提供种子节点，您将能够快速填充您的地址。种子节点不会保留为对等节点，但会在提供对等节点列表后与您的节点断开连接。 [!Tip] : 如果需要共享节点以便其他人连接，则需要设置external_address=\"节点公网IP\" 验证者节点配置: Config Option Setting pex false persistent_peers list of sentry nodes private_peer_ids none unconditional_peer_ids optionally sentry node IDs addr_book_strict false double_sign_check_height 0 哨兵节点配置: Config Option Setting pex true persistent_peers validator node, optionally other sentry nodes private_peer_ids validator node ID unconditional_peer_ids validator node ID, optionally sentry node IDs addr_book_strict false 种子节点配置: Config Option Setting addr_book_strict true pex true seed_mode true "},"cn/basic/accounts-faq.html":{"url":"cn/basic/accounts-faq.html","title":"钱包和地址","keywords":"","body":"Accounts 本文档介绍了 Cosmos SDK 的内置账号和公钥系统。 开始前读物 Cosmos SDK Accounts Keys, accounts, addresses, and signatures 对用户进行身份验证的主要方式是使用 数字签名。 用户使用自己的私钥签署交易。 签名验证是使用关联的公钥完成的。 出于链上签名验证的目的，我们将公钥存储在Account对象中（以及正确交易验证所需的其他数据）。 在节点中，所有数据都使用 Protocol Buffers 序列化存储。 Cosmos SDK 支持以下用于创建数字签名的数字密钥方案： secp256k1, 在 SDK's crypto/keys/secp256k1 package 包中实现. secp256r1, 在 SDK's crypto/keys/secp256r1 package 包中实现. tm-ed25519, 在 SDK crypto/keys/ed25519 package 包中实现. 该方案仅支持共识验证。 地址长度（以字节为单位） 公钥长度(以字节为单位) 用于交易认证 用于共识认证 secp256k1 20 33 yes no secp256r1 32 33 yes no tm-ed25519 -- not used -- 32 no yes 地址 Addresses 和 PubKeys 都是识别应用程序中参与者的公共信息。 Account 用于存储认证信息。 基本帐户实现由BaseAccount对象提供。 每个帐户都使用address标识，地址是从公钥派生的字节序列。 在 SDK 中，我们定义了 3 种类型的地址，用于指定使用帐户的上下文： AccAddress 标识用户（message 的发送者）。 ValAddress 标识验证器操作符。 ConsAddress 标识参与共识的验证器节点。 验证器节点是使用 ed25519 曲线导出的。 这些类型实现了 Address 接口： +++ https://github.com/cosmos/cosmos-sdk/blob/v0.42.1/types/address.go#L71-L90 Address 构造算法定义在 ADR-28. 以下是从pub公钥获取帐户地址的标准方法: sdk.AccAddress(pub.Address().Bytes()) 对于用户交互，地址使用 Bech32 格式化并通过 String 方法实现。 Bech32 方法是与区块链交互时唯一支持使用的格式。 Bech32 人类可读部分（Bech32 前缀）用于表示地址类型。 例子： +++ https://github.com/cosmos/cosmos-sdk/blob/v0.42.1/types/address.go#L230-L244 Address Bech32 Prefix Accounts gx Validator Operator gxvaloper Consensus Nodes gxvalcons Public Keys Cosmos SDK 中的公钥由 cryptotypes.PubKey 接口定义。 由于公钥保存在store中，cryptotypes.PubKey 扩展了 proto.Message 接口： +++ https://github.com/cosmos/cosmos-sdk/blob/v0.42.1/crypto/types/types.go#L8-L17 压缩格式用于secp256k1和secp256r1序列化。 公钥不用于引用帐户（或用户），通常在编写交易消息时不使用（除了少数例外：MsgCreateValidator、Validator 和 Multisig 消息）。 对于用户交互，PubKey 使用 Protobufs JSON (ProtoMarshalJSON 函数格式化 ）。 例子： +++ https://github.com/cosmos/cosmos-sdk/blob/7568b66/crypto/keyring/output.go#L23-L39 Keyring Keyring 是一个存储和管理帐户的对象。 在 Cosmos SDK 中，Keyring 实现遵循 Keyring 接口： +++ https://github.com/cosmos/cosmos-sdk/blob/v0.42.1/crypto/keyring/keyring.go#L51-L89 "},"cn/basic/accounts.html":{"url":"cn/basic/accounts.html","title":"使用","keywords":"","body":"钱包 地址例子： Address (Bech32): gx17jhdv3wj0a82h2xt007tag53farz5gvvzw2lnn Address (Hex): F4AED645D27F4EABA8CB7BFCBEA2914F462A218C Public Key (Bech32): gxpub1addwnpepq05dh673npd5pe2sz457qv2ypcmmelc8xpmv8zespmah02aaxtlpy8xlv5c 创建钱包地址 plugchaind keys add wallet1 [!warning]: Enter keyring passphrase:123123132 Re-enter keyring passphrase:123123123 初次输入的密码 123123123 为钱包密码，需要保存好，以下操作使用的密码都是此密码，如忘记此密码，想操作地址，必须把地址的助记词导入到另一个节点或者浏览器使用 返回信息 - name: wallet1 type: local address: gx17jhdv3wj0a82h2xt007tag53farz5gvvzw2lnn pubkey: gxpub1addwnpepq05dh673npd5pe2sz457qv2ypcmmelc8xpmv8zespmah02aaxtlpy8xlv5c mnemonic: \"\" threshold: 0 pubkeys: [] **Important** write this mnemonic phrase in a safe place. It is the only way to recover your account if you ever forget your password. nut blame match license torch away uncover pair nose diagram pepper digital chef pattern traffic garden coral impact wall december renew desert little under [!danger]: nut blame match license torch away uncover pair nose diagram pepper digital chef pattern traffic garden coral impact wall december renew desert little under 是地址的助记词， 极为重要，需要手动保存起来 查看钱包所有地址 plugchaind keys list 输出内容如下： - name: ds type: local address: gx1yh9a0trjulf92m9nr4g90c9fwq3kcwnkwjdv9u pubkey: gxpub1addwnpepqt7llu0440cytsulyzqgjxjuhtjxk5grwuqraekvrp2p7ud3rxgmsnhezn5 mnemonic: \"\" threshold: 0 pubkeys: [] - name: newwallet1 type: local address: gx1k7fzatpnurg9hen3ymug6f7cv2t3dy74ahtuxa pubkey: gxpub1addwnpepqw2hz7dvuq5r94w8xezfg65efnhmanklhspv6078qm0sux3z7uh6yktyn2n mnemonic: \"\" threshold: 0 pubkeys: [] 查看固定地址信息 plugchaind keys show newwallet1 查看地址信息 plugchaind q account gx17jhdv3wj0a82h2xt007tag53farz5gvvzw2lnn 如果返回信息如下： Error: post failed: Post \"http://localhost:26657\": dial tcp [::1]:26657: connect: connection refused 需要启动node节点服务 Error: rpc error: code = NotFound desc = rpc error: code = NotFound desc = account gx17jhdv3wj0a82h2xt007tag53farz5gvvzw2lnn not found: key not found 说明地址不存在或者地址没有币 正常返回信息： '@type': /cosmos.auth.v1beta1.BaseAccount account_number: \"10\" address: gx17jhdv3wj0a82h2xt007tag53farz5gvvzw2lnn pub_key: null sequence: \"0\" 导出地址私钥 plugchaind keys export wallet1 返回信息： -----BEGIN TENDERMINT PRIVATE KEY----- kdf: bcrypt salt: 4C80A5888778604BA31C06609A0F7BD3 type: secp256k1 E9rkBYnTPYTkzu+iI3/7b7Z6fDuAIoprLF2t824HaXnse67yJXYl+C/nW8d9246I jNhi7C0vFPnKt3lbxD6ghjAKYgg52u65Eu2FZRk= =kmrX -----END TENDERMINT PRIVATE KEY----- 导入地址私钥 需要把导出的私钥信息保存到一个文件，例如 wallet1.txt plugchaind keys import newmallet ./wallet1.txt 导入成功之后，没有任何返回信息，确认是否导入成功，使用 plugchaind keys show newwallet 导入地址助记词 plugchaind keys add newwallet1 --recover 命令执行之后，会出现交互内容，要求输入地址的助记词，如下： > Enter your bip39 mnemonic 然后输入助记词 nut blame match license torch away uncover pair nose diagram pepper digital chef pattern traffic garden coral impact wall december renew desert little under 如果节点存在这个地址，输入密码之后会报错，如下： Enter keyring passphrase: Error: public key already exist in keybase 如果节点没有当前地址，导入成功之后，信息如下： plugchaind keys add newwallet1 --recover > Enter your bip39 mnemonic wage sort make special maximum soup wheel high myth tongue skirt half dove connect ready camera giraffe surround dove member harsh inner rural coach Enter keyring passphrase: - name: newwallet1 type: local address: gx1k7fzatpnurg9hen3ymug6f7cv2t3dy74ahtuxa pubkey: gxpub1addwnpepqw2hz7dvuq5r94w8xezfg65efnhmanklhspv6078qm0sux3z7uh6yktyn2n mnemonic: \"\" threshold: 0 pubkeys: [] "},"cn/basic/tx.html":{"url":"cn/basic/tx.html","title":"交易","keywords":"","body":"账户交易 一. 查看tx参数 Transactions subcommands Usage: plugchaind tx [flags] plugchaind tx [command] Available Commands: bank Bank transaction subcommands broadcast Broadcast transactions generated offline crisis Crisis transactions subcommands decode Decode an binary encoded transaction string. distribution Distribution transactions subcommands encode Encode transactions generated offline evidence Evidence transaction subcommands gov Governance transactions subcommands ibc IBC transaction subcommands ibc-transfer IBC fungible token transfer transaction subcommands multisign Generate multisig signatures for transactions generated offline sign Sign a transaction generated offline sign-batch Sign transaction batch files slashing Slashing transaction subcommands staking Staking transaction subcommands token token transactions subcommands validate-signatures Validate transactions signatures vesting Vesting transaction subcommands vesting Vesting transaction subcommands Flags: --chain-id string The network chain ID (default \"token\") -h, --help help for tx Global Flags: --home string directory for config and data (default \"/root/.token\") --log_format string The logging format (json|plain) (default \"plain\") --log_level string The logging level (trace|debug|info|warn|error|fatal|panic) (default \"info\") --trace print out full stack trace on errors Additional help topics: plugchaind tx upgrade Upgrade transaction subcommands Use \"plugchaind tx [command] --help\" for more information about a command. - 其中我们经常用到的有 模块 概述 bank 转账模块 ibc 跨链通信模块 staking 质押模块 二. bank-send 转账参数 使用 plugchaind tx bank send -h 查看用法和参数 Usage: tokend tx bank send [from_key_or_address] [to_address] [amount] [flags] Flags: -a, --account-number uint The account number of the signing account (offline mode only) -b, --broadcast-mode string Transaction broadcasting mode (sync|async|block) (default \"sync\") --dry-run ignore the --gas flag and perform a simulation of a transaction, but don't broadcast it --fees string Fees to pay along with transaction; eg: 10uatom --from string Name or address of private key with which to sign --gas string gas limit to set per-transaction; set to \"auto\" to calculate sufficient gas automatically (default 200000) --gas-adjustment float adjustment factor to be multiplied against the estimate returned by the tx simulation; if the gas limit is set manually this flag is ignored (default 1) --gas-prices string Gas prices in decimal format to determine the transaction fee (e.g. 0.1uatom) --generate-only Build an unsigned transaction and write it to STDOUT (when enabled, the local Keybase is not accessible) -h, --help help for send --keyring-backend string Select keyring's backend (os|file|kwallet|pass|test|memory) (default \"test\") --keyring-dir string The client Keyring directory; if omitted, the default 'home' directory will be used --ledger Use a connected Ledger device --memo string Memo to send along with transaction --node string : to tendermint rpc interface for this chain (default \"tcp://localhost:26657\") --offline Offline mode (does not allow any online functionality -s, --sequence uint The sequence number of the signing account (offline mode only) --sign-mode string Choose sign mode (direct|amino-json), this is an advanced feature --timeout-height uint Set a block timeout height to prevent the tx from being committed past a certain height -y, --yes Skip tx broadcasting prompt confirmation Global Flags: --chain-id string The network chain ID (default \"token\") --home string directory for config and data (default \"/root/.token\") --log_format string The logging format (json|plain) (default \"plain\") --log_level string The logging level (trace|debug|info|warn|error|fatal|panic) (default \"info\") --trace print out full stack trace on errors 交易参数名词解释 tokend tx bank send [from_key_or_address] [to_address] [amount] [flags] 参数 解释 from_key_or_address 发送方地址 to_address 接收方地址 amount 金额 flags 其他参数(--home --chain-id等) --fees 手续费 --gas 手续费limit --gas-price 手续费价格 其中发起交易的时候需要额外设置手续费参数 plug的单位有6位小数 结果要/1000000才是正常的单位 即命令行中的10000plug实际为0.01plug) 三. 实现账户之间的转账 1. 直接指定本次交易手续费(10000plug) --fees plugchaind tx bank send $from $to 10plug --fees 10000plug --chain-id testnet --home home1 2. 分开设置,那么总用量就是 gas*gas-pirce 结果是(20000plug) --gas 手续费用量 默认 200000 --gas-prices gas价格 比如 0.1plugplugchaind tx bank send $from $to 100000plug --gas 200000 --gas-prices 0.0001plug --chain-id plugchain-testnet-1 --home home1 注意事项 在设置手续费的时候要注意各个节点设置的最小手续费价格 不能小于最小价格 minimum-gas-prices = \"0.1plug\" "},"cn/basic/txs.html":{"url":"cn/basic/txs.html","title":"交易步骤","keywords":"","body":"本文交易步骤，以转账为例 参数 两个地址- name: wallet1 type: local address: gx1cpq88us4kprcdd4fy4z5halwkr8h5eejrgacsq pubkey: gxpub1addwnpepqf0egzqdu83e4yvd3hsw4mck0d7jjkhq76d5etc2rymmkhxtlv4pxw7r8st mnemonic: \"\" threshold: 0 pubkeys: [] - name: wallet2 type: local address: gx173axkxh93lgtj3x9ddjvhtyy32xrq6q5pk04e9 pubkey: gxpub1addwnpepqf0du4l04hqquvz7q3ydq75uma6zu3q8ylk2qhydv5ka56edzu0v2y8gznl mnemonic: \"\" threshold: 0 pubkeys: [] 需求：wallet1 向 wallet2 转账一笔 生成无符号tx plugchaind tx bank send $(plugchaind keys show wallet1 -a --home node1) \\ $(plugchaind keys show wallet2 -a --home node1) 1000000plug \\ --from wallet1 --fees 20plug --chain-id plugchain --generate-only > tx.json tx.json信息如下: { \"body\": { \"messages\": [ { \"@type\": \"/cosmos.bank.v1beta1.MsgSend\", \"from_address\": \"gx1cpq88us4kprcdd4fy4z5halwkr8h5eejrgacsq\", \"to_address\": \"gx173axkxh93lgtj3x9ddjvhtyy32xrq6q5pk04e9\", \"amount\": [ { \"denom\": \"plug\", \"amount\": \"1000000\" } ] } ], \"memo\": \"\", \"timeout_height\": \"0\", \"extension_options\": [], \"non_critical_extension_options\": [] }, \"auth_info\": { \"signer_infos\": [], \"fee\": { \"amount\": [ { \"denom\": \"plug\", \"amount\": \"5000\" } ], \"gas_limit\": \"200000\", \"payer\": \"\", \"granter\": \"\" } }, \"signatures\": [] } 对无符号tx签名 plugchaind tx sign tx.json --from wallet1 --chain-id plugchain -y > tx-sign.json tx-sign.json信息： { \"body\": { \"messages\": [ { \"@type\": \"/cosmos.bank.v1beta1.MsgSend\", \"from_address\": \"gx1cpq88us4kprcdd4fy4z5halwkr8h5eejrgacsq\", \"to_address\": \"gx173axkxh93lgtj3x9ddjvhtyy32xrq6q5pk04e9\", \"amount\": [ { \"denom\": \"plug\", \"amount\": \"1000000\" } ] } ], \"memo\": \"\", \"timeout_height\": \"0\", \"extension_options\": [], \"non_critical_extension_options\": [] }, \"auth_info\": { \"signer_infos\": [ { \"public_key\": { \"@type\": \"/cosmos.crypto.secp256k1.PubKey\", \"key\": \"Al+UCA3h45qRjY3g6u8We30pWuD2m0yvChk3u1zL+yoT\" }, \"mode_info\": { \"single\": { \"mode\": \"SIGN_MODE_DIRECT\" } }, \"sequence\": \"0\" } ], \"fee\": { \"amount\": [ { \"denom\": \"plug\", \"amount\": \"5000\" } ], \"gas_limit\": \"200000\", \"payer\": \"\", \"granter\": \"\" } }, \"signatures\": [ \"MCJY9Gxg9pMEjj4Dn+WvD5z7GgR93M8pWSsfgnrQVBRj1rSm5CNG8ZOwpICPfvPuBoyyFJzehDzdIQU4rd29vQ==\" ] } 对签名交易信息编码plugchaind tx encode tx-sign.json 输出如下：CooBCocBChwvY29zbW9zLmJhbmsudjFiZXRhMS5Nc2dTZW5kEmcKKWd4MWNwcTg4dXM0a3ByY2RkNGZ5NHo1aGFsd2tyOGg1ZWVqcmdhY3NxEilneDE3M2F4a3hoOTNsZ3RqM3g5ZGRqdmh0eXkzMnhycTZxNXBrMDRlORoPCgRsaW5lEgcxMDAwMDAwEmQKTgpGCh8vY29zbW9zLmNyeXB0by5zZWNwMjU2azEuUHViS2V5EiMKIQJflAgN4eOakY2N4OrvFnt9KVrg9ptMrwoZN7tcy/sqExIECgIIARISCgwKBGxpbmUSBDUwMDAQwJoMGkAwIlj0bGD2kwSOPgOf5a8PnPsaBH3czylZKx+CetBUFGPWtKbkI0bxk7CkgI9+8+4GjLIUnN6EPN0hBTit3b29 广播交易curl --header \"Content-Type: application/json\" --request POST --data '{\"tx_bytes\":\"CooBCocBChwvY29zbW9zLmJhbmsudjFiZXRhMS5Nc2dTZW5kEmcKKWd4MWNwcTg4dXM0a3ByY2RkNGZ5NHo1aGFsd2tyOGg1ZWVqcmdhY3NxEilneDE3M2F4a3hoOTNsZ3RqM3g5ZGRqdmh0eXkzMnhycTZxNXBrMDRlORoPCgRsaW5lEgcxMDAwMDAwEmQKTgpGCh8vY29zbW9zLmNyeXB0by5zZWNwMjU2azEuUHViS2V5EiMKIQJflAgN4eOakY2N4OrvFnt9KVrg9ptMrwoZN7tcy/sqExIECgIIARISCgwKBGxpbmUSBDUwMDAQwJoMGkAwIlj0bGD2kwSOPgOf5a8PnPsaBH3czylZKx+CetBUFGPWtKbkI0bxk7CkgI9+8+4GjLIUnN6EPN0hBTit3b29\",\"mode\":1}' localhost:1317/cosmos/tx/v1beta1/txs 返回消息如下：{ \"tx_response\": { \"height\": \"292\", \"txhash\": \"D7CD55CDE644952F2DCAEB32DD6E865657210EBCBBAE2914B256292762702C69\", \"codespace\": \"\", \"code\": 0, \"data\": \"0A060A0473656E64\", \"raw_log\": \"[{\\\"events\\\":[{\\\"type\\\":\\\"message\\\",\\\"attributes\\\":[{\\\"key\\\":\\\"action\\\",\\\"value\\\":\\\"send\\\"},{\\\"key\\\":\\\"sender\\\",\\\"value\\\":\\\"gx1cpq88us4kprcdd4fy4z5halwkr8h5eejrgacsq\\\"},{\\\"key\\\":\\\"module\\\",\\\"value\\\":\\\"bank\\\"}]},{\\\"type\\\":\\\"transfer\\\",\\\"attributes\\\":[{\\\"key\\\":\\\"recipient\\\",\\\"value\\\":\\\"gx173axkxh93lgtj3x9ddjvhtyy32xrq6q5pk04e9\\\"},{\\\"key\\\":\\\"sender\\\",\\\"value\\\":\\\"gx1cpq88us4kprcdd4fy4z5halwkr8h5eejrgacsq\\\"},{\\\"key\\\":\\\"amount\\\",\\\"value\\\":\\\"1000000plug\\\"}]}]}]\", \"logs\": [ { \"msg_index\": 0, \"log\": \"\", \"events\": [ { \"type\": \"message\", \"attributes\": [ { \"key\": \"action\", \"value\": \"send\" }, { \"key\": \"sender\", \"value\": \"gx1cpq88us4kprcdd4fy4z5halwkr8h5eejrgacsq\" }, { \"key\": \"module\", \"value\": \"bank\" } ] }, { \"type\": \"transfer\", \"attributes\": [ { \"key\": \"recipient\", \"value\": \"gx173axkxh93lgtj3x9ddjvhtyy32xrq6q5pk04e9\" }, { \"key\": \"sender\", \"value\": \"gx1cpq88us4kprcdd4fy4z5halwkr8h5eejrgacsq\" }, { \"key\": \"amount\", \"value\": \"1000000plug\" } ] } ] } ], \"info\": \"\", \"gas_wanted\": \"200000\", \"gas_used\": \"74685\", \"tx\": null, \"timestamp\": \"\" } } 转账完成 "},"cn/validators/validator-faq.html":{"url":"cn/validators/validator-faq.html","title":"验证者","keywords":"","body":" 验证器常见问题 什么是验证器？ Plugchain 基于 Tendermint，它依赖一组验证器来保护网络。验证者的作用是运行一个全节点并通过广播包含由其私钥签名的加密签名的投票来参与共识。验证者在区块链中提交新区块并获得收入以换取他们的工作。他们还必须通过对提案进行投票来参与治理。验证者根据他们的总权益加权。 什么是质押？ Plugchain 是一个公共的权益证明 (PoS) 区块链，这意味着验证者的权重取决于作为抵押品的抵押代币 (plug) 的数量。这些插件可以由验证者直接自行委托或由其他插件持有者委托给他们。 系统中的任何用户都可以通过发送“创建验证器”交易来声明他们成为验证器的意图。从那里，他们成为验证者候选人。 验证者的权重（即投票权）决定了他们是否是活跃的验证者。最初，只有拥有最多投票权的前 100 名验证者才会成为活跃验证者。 什么是全节点？ 全节点是一个完全验证区块链交易和区块的程序。它不同于仅处理区块头和一小部分交易的轻节点。运行全节点需要比轻节点更多的资源，但这是成为验证者所必需的。在实践中，运行全节点仅意味着以低网络延迟和无停机时间运行非妥协和最新版本的软件。 当然，即使他们不打算成为验证者，也可以并鼓励用户运行全节点。 什么是委托人？ 委托人是不能或不想自己运行验证器的插件持有者。插件持有者可以将插件委托给验证者并作为交换获得他们的部分收入 因为他们与验证人分享收入，所以委托人也分担风险。如果验证者行为不端，他们的每个委托人将根据其委托的股份比例被部分削减。这就是为什么委托人应该在委托之前对验证人进行尽职调查，并将他们的股份分配给多个验证人。 委托人在系统中起着至关重要的作用，因为他们负责选择验证人。作为委托人不是一个被动的角色：委托人应该积极监控验证人的行为并参与治理。有关更多信息，请阅读 委托人常见问题解答。 成为验证者 如何成为验证者？ 网络中的任何参与者都可以通过发送“create-validator”交易来表示他们想成为验证者，他们必须填写以下参数： Validator's PubKey： 与 Tendermint PubKey 关联的私钥用于签署 prevotes 和 precommits。 验证者地址： 应用层地址。这是用于公开识别您的验证者的地址。与此地址关联的私钥用于委托、解除绑定、领取奖励和参与治理。 验证者的名字(moniker) 验证者的网站(website) 验证者的描述 details： 验证器的（可选）详细信息 Initial commission rate：区块奖励和向委托人收取的费用的佣金率。 Maximum commission： 该验证器可以收取的最大佣金率。处理完 create-validator 后无法更改此参数。 Commission max change rate： 验证人佣金的最大每日增量。处理完 create-validator 后无法更改此参数。 Minimum self-delegation： 验证者需要始终绑定的最小插件数量。如果验证者的自委托权益低于此限制，则他们的整个权益池将解除绑定。 创建验证器后，插件持有者可以将插件委托给他们，从而有效地将权益添加到他们的池中。一个地址的总权益是委托人绑定的plug和自己指定的实体自己绑定的plug的组合。 在所有向自己发出信号的验证者候选人中，总权益最多的 100 名被指定为验证者。他们成为验证者 如果验证者的总股份低于前 100 名，那么该验证者将失去其验证者特权：他们不再参与共识并产生奖励。随着时间的推移，验证者的最大数量可能会通过链上治理提案增加。 有哪些不同类型的密钥？ 简而言之，有两种类型的键： Tendermint Key：这是用于签署共识投票的唯一密钥。 它与公钥plugvalconspub 相关联（使用plugchaind tendenmint show-validator 获取该值） 在使用 plugchaind init 创建节点时生成。 应用程序密钥：此密钥由plugchaind创建并用于签署交易。应用程序密钥与以“plugpub”为前缀的公钥和以“plug”为前缀的地址相关联。两者都源自plugchaind keys add生成的帐户密钥。 注意：验证器的操作员密钥直接绑定到应用程序密钥，但 仅为此目的使用保留前缀：plugvaloper 和 plugvaloperpub 验证器可以处于哪些不同状态？ 使用 create-validator 交易创建验证器后，它们可以处于三种状态： 在验证者集中：验证者在活跃集中并参与共识。验证者正在获得奖励，可能会因不当行为而被削减。 jailed：验证器行为不端并且在监狱中，即在验证器集合之外。如果由于离线时间过长而被监禁，验证者可以发送“unjail”交易以重新进入验证者集合。如果监禁是由于双重签名，则验证者无法解除监禁。 unbonded：验证者不在活动集中，因此不会签署区块。验证者不能被削减，也不会获得任何奖励。仍然可以将 plug 委托给这个验证器。从“非绑定”验证器取消委托是立即的。 什么是“自我授权”？我怎样才能增加我的“自我授权”？ 自我委托是验证者对自己的委托。可以通过从验证者的“应用程序”应用程序密钥发送“委托”交易来增加此金额。 是否有最低数量的插件必须被委派为活动（=绑定）验证器？ 最小值为“1 个插头”。 委托人将如何选择他们的验证人？ 委托人可以根据自己的主观标准自由选择验证人。也就是说，预计很重要的标准包括： 自我委托的插件数量：验证者自我委托给自己的插件数量。拥有更多自委托插件的验证器在游戏中拥有更多的皮肤，使他们对自己的行为更负责。 委托的插件数量：委托给验证者的插件总数。高投票权表明社区信任这个验证者，但也意味着这个验证者是黑客更大的目标。更大的验证器也会降低网络的去中心化程度。 佣金率： 在分配给委托人之前，验证者对收入应用的佣金。 跟踪记录：委托人可能会查看他们计划委托给的验证者的跟踪记录。这包括资历、过去对提案的投票、历史平均正常运行时间以及节点被入侵的频率。 除了这些标准之外，验证者还有可能通过一个网站地址来完成他们的简历。验证者需要以一种或另一种方式建立声誉来吸引委托人。例如，让验证者的设置由第三方审计将是一个很好的做法。但请注意，Tendermint 团队不会自行批准或进行任何审核。 职责 验证器需要公开识别吗？ 不，他们没有。每个委托人将根据自己的标准对验证人进行评估。验证者在提名自己时将能够注册一个网站地址，以便他们可以在他们认为合适的情况下宣传他们的操作。一些委托人可能更喜欢一个网站，该网站清楚地显示运营验证人的团队及其简历，而其他人可能更喜欢具有良好记录的匿名验证人。 验证者的职责是什么？ 验证者有两个主要职责： 能够持续运行正确版本的软件：验证者需要确保他们的服务器始终在线并且他们的私钥没有被泄露。 积极参与治理：验证者需要对每个提案进行投票。 此外，验证者有望成为社区的活跃成员。他们应该始终了解生态系统的当前状态，以便他们可以轻松适应任何变化。 “参与治理”意味着什么？ Plugchain Hub 上的验证者和委托者可以对更改操作参数（例如区块 gas 限制）、协调升级或对任何给定事项做出决定的提案进行投票。 验证者在治理系统中扮演着特殊的角色。作为系统的支柱，他们必须对每个提案进行投票。这一点尤其重要，因为不投票的委托人将继承其验证人的投票。 质押意味着什么？ Staking plug 可以被认为是验证活动的安全押金。当验证者或委托人想要取回部分或全部存款时，他们会发送“解除绑定”交易。然后，plug 会经历 3 周的解绑期，在此期间，他们很可能会因验证者在解绑过程开始之前犯下的潜在不当行为而受到惩罚。 验证者和协会委托人获得区块奖励、费用，并有权参与治理。如果验证者行为不端，则其总权益的一部分将被削减。这意味着每个将插件绑定到该验证器的委托人都会按其绑定的股份比例受到惩罚。因此，委托人被激励委托给他们预期将安全运行的验证人。 验证者可以带着委托人的插件逃跑吗？ 通过委托给验证者，用户委托投票权。验证者拥有的投票权越大，他们在共识和治理过程中的权重就越大。这并不意味着验证者可以保管其委托人的插件。 绝不能让验证者带着委托人的资金逃跑。 尽管委托资金不能被验证人窃取，但如果验证人行为不端，委托人仍需承担责任。 多久会选择一个验证者来提出下一个区块？是否随保税插头的数量而增加？ 被选中提出下一个区块的验证者称为提议者。每个提议者都是确定性选择的，被选择的频率与验证者的投票权（即绑定插头的数量）成正比。例如，如果所有验证者的总抵押权益为 100 plug，而一个验证者的总权益为 10 plug，那么该验证者将提议约 10% 的区块。 plugchain Hub 的验证者是否需要验证 plugchain 生态系统中的其他区域？ 是他们会。如果治理决定如此，则可能需要插件链中心的验证器来验证插件链生态系统中的其他区域。 激励措施 质押的动机是什么？ 验证者权益池的每个成员都会获得不同类型的收入： 区块奖励： 验证者运行的应用程序的原生代币（例如，plugchain Hub 上的插件）被膨胀以产生区块供应。这些规定的存在是为了激励插头持有人将其股权绑定，因为非绑定插头会随着时间的推移而被稀释。 交易费用： Plugchain Hub 维护一个被接受为费用支付的代币白名单。初始费用代币是plug。 该总收入根据每个验证者的权重在验证者的权益池中分配。然后，在每个验证者的权益池中，收入按照每个委托人的权益按比例分配给委托人。委托人收入的佣金在分配之前由验证人收取。 运行验证器的动机是什么？ 由于佣金，验证者按比例获得比委托人更多的收入。 验证者在治理中也发挥着重要作用。如果委托人不投票，他们会从验证人那里继承投票。这赋予验证者在生态系统中的主要责任。 什么是验证人佣金？ 验证者池收到的收入在验证者和他们的委托人之间分配。验证者可以对分配给其委托人的收入部分收取佣金。该佣金设置为百分比。每个验证者都可以自由设置他们的初始佣金、最大每日佣金变化率和最大佣金。 Plugchain Hub 强制执行每个验证器设置的参数。创建验证器后，只能更改佣金率。 区块奖励如何分配？ 区块奖励相对于他们的投票权按比例分配给所有验证者。这意味着即使每个验证者都获得了奖励，但随着时间的推移，所有验证者都将保持相等的权重。 让我们举一个例子，我们有 10 个具有相同投票权和 1% 佣金率的验证器。我们还假设一个区块的奖励是 1000 plug，并且每个验证者都有 20% 的 self-bonded plug。这些代币不会直接交给提议者。相反，它们均匀分布在验证器中。所以现在每个验证者的池都有 100 个插头。这 100 个插头将根据每个参与者的股份分配： 佣金：100*80%*1% = 0.8 插头 验证者获得：100\\*20% + Commission = 20.8 plug 所有委托人获得：100\\*80% - Commission = 79.2 plug 然后，每个委托人都可以根据他们在验证人的抵押池中的股份比例要求他们在 79.2 插件中的份额。 费用如何分配？ 费用以类似的方式分配，但区块提议者可以在他们提议的区块费用上获得奖金，如果他们包括超过严格的最低要求的预提交。 当验证者被选中提出下一个区块时，他们必须至少包含前一个区块的 2/3 预提交。但是，以奖金的形式包含超过 2/3 的预提交是有动力的。奖励是线性的：如果提议者包含 2/3 次预提交（区块有效的最小值），则为 1%，如果提议者包含 100% 预提交，则为 5%。当然，提议者不应等待太久，否则其他验证者可能会超时并转移到下一个提议者。因此，验证者必须在获得最多签名的等待时间和失去提议下一个区块的风险之间找到平衡。该机制旨在激励非空区块提议、验证者之间更好的网络以及减轻审查。 让我们举一个具体的例子来说明上述概念。在这个例子中，有 10 个验证者的权益相等。他们每个人都适用 1% 的佣金率和 20% 的自委托插头。现在来了一个成功的区块，它总共收取了 1025.51020408 个插件费用。 首先，征收 2% 的税。相应的插头进入备用池。储备池的资金可以通过治理分配来资助赏金和升级。 2% * 1025.51020408 = 20.51020408 插头进入储备池。 1005 插头现在仍然存在。让我们假设提议者在其区块中包含 100% 的签名。因此，它获得了 5% 的全额奖金。 我们必须解决这个简单的等式才能找到每个验证器的奖励 R： 9*R + R + R*5% = 1005 ⇔ R = 1005/10.05 = 100 对于提议者验证者： 矿池获得R + R * 5%：105插头 佣金：105 * 80% * 1% = 0.84 插头 验证者的奖励：105 * 20% + Commission = 21.84 plug 委托人的奖励：105 * 80% - 佣金 = 83.16 插件（每个委托人都可以按照他们的股份比例领取这些奖励的一部分） 对于每个非提议者验证者： 池获得R：100插头 佣金：100 * 80% * 1% = 0.8 插头 验证者的奖励：100 * 20% + Commission = 20.8 plug 委托人的奖励：100 * 80% - 佣金 = 79.2 插件（每个委托人都可以按照他们的股份比例领取这些奖励的部分） 削减条件是什么？ 如果验证者行为不端，他们的委托权益将被部分削减。目前有两个错误可能导致验证者及其委托人的资金被削减： 双重签名： 如果有人在链 A 上报告说一个验证者在链 A 和链 B 上签署了两个高度相同的区块，并且如果链 A 和链 B 共享一个共同的祖先，那么这个验证者将被削减链 A 上的 5%。 停机时间： 如果验证者错过了最后 10.000 个区块中的 95% 以上，他们将被削减 0.01%。 验证器需要自我委托插件吗？ 是的，他们确实需要自我委托至少“1 个插头”。即使验证人没有义务自我委托超过“1 个插件”，委托人也应该希望他们的验证人在他们的抵押池中有更多的自我委托插件。换句话说，验证者应该在游戏中拥有皮肤。 为了让委托人对他们的验证人在游戏中拥有多少皮肤有一定的保证，后者可以发出最少量的自我委托插件信号。如果验证者的自我委托低于其预定义的限制，则该验证者及其所有委托者将解除绑定。 如何防止少数顶级验证者手中的股权集中？ 目前，社区应该以聪明和自我保护的方式行事。当比特币中的矿池获得过多的算力时，社区通常会停止对该矿池做出贡献。 Plugchain Hub 最初将依赖相同的效果。其他机制可以尽可能地简化这个过程： 无惩罚重新委托： 这是为了让委托人可以轻松地从一个验证器切换到另一个验证器，以减少验证器的粘性。 UI 警告： 钱包可以实施警告，如果用户想要委托给已经拥有大量权益的验证者，这些警告将显示给用户。 ＃＃ 技术要求 什么是硬件要求？ 验证者应该期望为一个或多个数据中心位置提供冗余电源、网络、防火墙、HSM 和服务器。 我们预计最初将需要适度的硬件规格，并且随着网络使用的增加，它们可能会增加。 参与测试网是了解更多信息的最佳方式。 什么是软件要求？ 除了运行插件链中心节点之外，验证者还应该开发监控、警报和管理解决方案。 带宽要求是什么？ 与以太坊或比特币等链相比，plugchain 网络具有非常高的吞吐量。 我们建议数据中心节点只连接到云中可信的全节点或其他在社交上相互认识的验证器。这减轻了数据中心节点减轻拒绝服务攻击的负担。 最终，随着网络的使用越来越频繁，每天数千兆字节的带宽是非常现实的。 运行验证器在物流方面意味着什么？ 一个成功的验证器操作需要多个高技能人员的努力和持续的操作关注。例如，这将比运行比特币矿工要复杂得多。 如何处理密钥管理？ 验证者应该期望运行支持 ed25519 密钥的 HSM。以下是潜在的选择： YubiHSM 2 分类帐纳米 S 分类帐 BOLOS SGX 飞地 泰雷兹 nShield 支持 Tendermint 团队不推荐一种高于另一种的解决方案。鼓励社区加强努力以改进 HSM 和密钥管理的安全性。 验证者在操作方面可以期待什么？ 运行有效操作是避免意外脱胶或被割伤的关键。这包括能够响应攻击、中断以及保持数据中心的安全性和隔离性。 维护要求是什么？ 验证者应该期望执行定期软件更新以适应升级和错误修复。网络在引导阶段的早期不可避免地会出现问题，需要高度警惕。 验证者如何保护自己免受拒绝服务攻击？ 当攻击者向某个 IP 地址发送大量 Internet 流量以阻止该 IP 地址上的服务器连接到 Internet 时，就会发生拒绝服务攻击。 攻击者扫描网络，试图了解各种验证器节点的 IP 地址，并通过向它们注入流量来断开它们的通信。 降低这些风险的一种推荐方法是让验证者在所谓的哨兵节点架构中仔细构建他们的网络拓扑。 验证器节点应该只连接到他们信任的全节点，因为它们自己操作或由他们在社交上认识的其他验证器运行。验证器节点通常会在数据中心内运行。大多数数据中心提供与主要云提供商网络的直接链接。验证器可以使用这些链接连接到云中的哨兵节点。这将拒绝服务的负担从验证者的节点直接转移到其哨兵节点，并且可能需要启动或激活新的哨兵节点以减轻对现有节点的攻击。 Sentry 节点可以快速启动或更改其 IP 地址。由于到哨兵节点的链接在私有 IP 空间中，基于 Internet 的攻击无法直接干扰它们。这将确保验证者区块提案和投票始终进入网络的其余部分。 预计这部分验证者的良好操作程序将完全缓解这些威胁。 "},"cn/validators/validator-setup.html":{"url":"cn/validators/validator-setup.html","title":"使用","keywords":"","body":"成为验证者参与主链生态管理 以下教程都依赖节点执行,如未安装,请移步到 安装节点 添加验证者 plugchaind tx staking create-validator [flags]plugchaind tx staking create-validator --from mywallet \\ --amount 1000000plug --pubkey $(plugchaind tendermint show-validator) \\ --moniker=\"my validator\" --commission-rate=\"0.10\" --commission-max-rate=\"0.20\" \\ --commission-max-change-rate=\"0.01\" --min-self-delegation=\"1000000\" --fees 20plug --chain-id plugchain 修改已经存在的验证者配置 plugchaind tx staking edit-validator [flags]plugchaind tx staking edit-validator --from mywallet \\ --moniker=\"my validator\" --commission-rate=\"0.20\" --min-self-delegation=\"1000000\" --fees 20plug --chain-id plugchain [!warning] : commission-max-rate,commission-max-change-rate 两个字段在create-validator设置完之后就不可以修改,请您慎重设置 edit-validator 修改验证者信息时,各字段修改间隔24H,min-self-delegation 不可减小,只能增加,没有更改的字段修改时不可添加 commission-rate的值必须符合如下的不变量检查： 必须在 0 和 验证人的commission-max-rate 之间 不得超过 验证人的commission-max-change-rate, 该参数标识每日最大的百分点变化数。也就是,一个验证人在commission-max-change-rate的界限内每24H一次可调整的最大佣金变化。 min-self-delegation的值单位是10e-6,所以此值最小为 1000000 查询验证者的所有委托人的质押总量,想了解委托人信息,请移步委托人质押 plugchaind query staking delegations-to [validator-addr] [flags]plugchaind query staking delegations-to gxvaloperxxxxxxxxxxxxxxxxxx 根据验证者查询所有取消质押的记录 plugchaind query staking unbonding-delegations-from [validator-addr] [flags]plugchaind query staking unbonding-delegations-from gxvaloperxxxxxxxxxxxxxxxxxxxxxxxxxxxx ::: warning 注意 为了能进入验证人集合,你的权重必须超过第100名的验证人。 ::: 成为验证者之后,需要修改配置validator config 常见问题 问题 #1 : 我的验证人的voting_power: 0 你的验证人已经是jailed状态。如果验证人在最近10000个区块中有超过500个区块没有进行投票,或者被发现双签,就会被jail掉。 如果被因为掉线而遭到jail,你可以重获你的投票股权以重回验证人队伍。首先,如果plugchaind没有运行,请再次启动： plugchaind start 等待你的全节点追赶上最新的区块高度。然后,运行如下命令。接着,你可以unjail你的验证人。 最后,检查你的验证人看看投票股权是否恢复： plugchaind status 你可能会注意到你的投票权比之前要少。这是由于你的下线受到的削减处罚！ 问题 #2 : 我的plugchaind由于too many open files而崩溃 Linux可以打开的默认文件数（每个进程）是1024。已知plugchaind可以打开超过1024个文件。这会导致进程崩溃。快速修复运行ulimit -n 4096（增加允许的打开文件数）来快速修复,然后使用plugchaind start重新启动进程。如果你使用systemd或其他进程管理器来启动plugchaind,则可能需要在该级别进行一些配置。解决此问题的示例systemd文件如下： # /etc/systemd/system/plugchaind.service [Unit] Description=plugchain Node After=network.target [Service] Type=simple User=ubuntu WorkingDirectory=/home/ubuntu ExecStart=/home/ubuntu/go/bin/plugchaind start Restart=on-failure RestartSec=3 LimitNOFILE=4096 [Install] WantedBy=multi-user.target "},"cn/delegators/delegator-faq.html":{"url":"cn/delegators/delegator-faq.html","title":"委托人","keywords":"","body":" 委托人常见问题 什么是委托人？ 不能或不想操作验证器节点的人仍然可以作为委托人参与抵押过程。事实上，验证者不是根据他们自己委托的股份来选择的，而是根据他们的总股份来选择的，这是他们自己委托的股份和委托给他们的股份的总和。这是一个重要的属性，因为它使委托人成为对表现出不良行为的验证者的保护措施。如果验证者行为不端，他们的委托人会将他们的插头从他们身上移开，从而减少他们的股份。最终，如果验证者的权益低于权益最高的前 125 个地址，他们将退出验证者集。 委托人分享其验证人的收入，但他们也分担风险。 在收入方面，验证人和委托人的不同之处在于，验证人可以在分配给委托人的收入中收取佣金，然后再分配。该佣金事先为委托人所知，并且只能根据预定义的约束进行更改（请参阅下面的[部分]（#choosing-a-validator））。在风险方面，如果他们的验证者行为不端，委托人的插件可能会被削减。有关更多信息，请参阅 风险 部分。 要成为委托人，插件持有者需要发送“委托交易”，在其中指定他们想要绑定的插件数量和验证者。验证器候选列表将显示在插件链中心浏览器中。之后，如果委托人想要解除部分或全部股权，他们需要发送“解除绑定交易”。从那里，委托人必须等待 3 周才能取回他们的插头。委托人还可以发送“重新绑定交易”以从一个验证器切换到另一个验证器，而无需经过 3 周的等待期。 有关如何成为委托人的实用指南，请单击 此处。 选择验证器 验证者的绰号：验证者候选人的姓名。 Validator's description：验证器运营商提供的描述。 验证者的网站：链接到验证者的网站。 初始佣金率：验证者向任何委托人收取的收入佣金率（更多详细信息见下文）。 佣金最大变化率： 验证人佣金的最大每日增量。验证器操作员无法更改此参数。 最高佣金： 该验证者候选人可以收取的最高佣金率。验证器操作员无法更改此参数。 最小自绑定数量：验证者候选人需要始终绑定的最小插件数量。如果验证者的自绑定权益低于此限制，则他们的整个权益池（即其所有委托人）将解除绑定。此参数作为委托人的保护措施而存在。事实上，当验证者行为不端时，他们的总权益的一部分会被削减。这包括验证者的自我委托权益以及他们的委托人权益。因此，具有大量自委托插件的验证器比具有低数量的验证器具有更多的游戏皮肤。最小自绑定数量参数向委托人保证，验证者永远不会低于一定数量的自绑定权益，从而确保游戏中的最低级别。此参数只能由验证器操作员增加。 委托人指令 作为委托人并不是一项被动的任务。以下是委托人的主要指令： 在委托前对验证人进行仔细的尽职调查。如果验证人行为不端，其总股份的一部分，包括其委托人的股份，可能会被削减。因此，委托人应该仔细选择他们认为行为正确的验证人。 在委托后积极监控他们的验证人。委托人应确保他们委托的验证人行为正确，这意味着他们有良好的正常运行时间，不会双重签名或受到损害，并参与治理。他们还应该监控所采用的佣金率。如果委托人对其验证人不满意，他们可以解绑或切换到另一个验证人（注意：委托人不必等待解绑期才能切换验证人。重新绑定立即生效）。 参与治理。 委托人可以并且应该积极参与治理。委托人的投票权与其抵押股份的大小成正比。如果委托人不投票，他们将继承其验证人的投票。如果他们投票，他们将推翻验证人的投票。因此，委托人对其验证人起到了平衡作用。 收入 验证者和委托者通过他们的服务赚取收入。该收入以三种形式给出： 出块的规定（plug）：它们在新创建的插件中支付。存在区块条款以激励插头持有者进行抵押。每年的通货膨胀率被计算为目标是 2/3 的保税股份。如果网络中的总保税股份少于总插头供应量的 2/3，通货膨胀会增加，直到达到 20%。如果总保税股份超过插头供应量的 2/3，通货膨胀会下降，直到达到 7%。这意味着，如果总保税股份在很长一段时间内保持低于总插头供应量的 2/3，则未保税插头持有人可以预期其插头价值每年减少 20%（复合）。 交易费用（various tokens）： Plugchain Hub 上的每次转账都会产生交易费用。这些费用可以以 Hub 治理白名单中的任何货币支付。费用按其股份比例分配给保税插头持有人。启动时第一个列入白名单的令牌是plug。 验证人委员会 每个验证者根据他们的总权益获得收入。在此收入分配给委托人之前，验证人可以申请佣金。换句话说，委托人必须根据他们赚取的收入向验证人支付佣金。让我们看一个具体的例子： 我们考虑一个验证者，其权益（即自委托权益 + 委托权益）是所有验证者总权益的 10%。该验证者拥有 20% 的自委托权益，并收取 10% 的佣金。现在让我们考虑一个具有以下收入的区块： 990 plug块规定 10 plug交易费用。 这总共有 1000 个plug和 100 个Photons要分布在所有的权益池中。 我们验证人的权益池占总权益的 10%，即获得 100 个 plug 和 10 个 Photons。现在让我们看看内部收入分配： 佣金 = 10% * 80% * 100 plug = 8 个plug 验证者的收入 = 20% * 100 plug + 佣金 = 28 plug 委托人的总收入 = 80% * 100 plug - 佣金 = 72 plug 然后，抵押池中的每个委托人都可以要求他们在委托人总收入中的份额。 风险 放样plug并非没有风险。首先，已放桩的plug被锁定，取回它们需要 3 周的等待期，称为解绑期。此外，如果验证者行为不端，其总权益的一部分可能会被削减（即销毁）。这包括其委托人的股份。 有一个主要的削减条件： 双重签名： 如果有人报告验证者在同一高度签署了具有相同链 ID 的两个不同区块，则该验证者将被削减。 这就是为什么plug持有者应该在委派之前对验证者进行仔细的尽职调查。委托人积极监控其验证人的活动也很重要。如果验证人行为可疑或经常离线，委托人可以选择与他们解除绑定或切换到另一个验证人。 委托人还可以通过在多个验证者之间分配他们的股份来降低风险。 "},"cn/delegators/delegator-setup.html":{"url":"cn/delegators/delegator-setup.html","title":"使用","keywords":"","body":"委托人质押 委托人质押需要选择验证者,查询所有验证者 plugchaind q staking validators [flags]plugchaind q staking validators --chain-id plugchain 找到自己满意的验证者,执行质押 plugchaind tx staking delegate [validator-addr] [amount] --from mykey [flags]plugchaind tx staking delegate gxvaloperxxxxxxxxxxxxxxxxxxxxx 20000plug \\ --from mywallet --fees 20plug --chain-id plugchain 更改自己的委托验证者 plugchaind tx staking redelegate [src-validator-addr] [dst-validator-addr] [amount] --from mykey [flags]plugchaind tx staking redelegate gxvaloperxxxxxxxxxxxxxxxxxxxx gxvaloperxxxxxxxxxxxxxxxxxxx 100000plug \\ --from mywallet --fees 20plug --chain-id plugchain 根据验证者查询未提取收益 plugchaind query distribution rewards [delegator-addr] [validator-addr] [flags] delegator-addr 是验证者地址 validator-addr 为 plugchaind q staking validators 命令根据moniker找到验证者信息,对应的validator-addrplugchaind query distribution rewards $(plugchaind keys show mywallet -a) [validator-addr] 提取所有未提取奖励 plugchaind tx distribution withdraw-all-rewards --from mykey [flags]plugchaind tx distribution withdraw-all-rewards --from mywallet 取消质押-锁仓21天 plugchaind tx staking unbond [validator-addr] [amount] --from mykeyplugchaind tx staking unbond gxvaloperxxxxxxxxxxxxxxxxxx 10000000plug --from mywallet --chain-id plugchain 质押限制 1.质押,取消质押: 取消质押币需要冻结21天后到账 2.转质押: 转质押后新节点对用户的转质押操作锁仓21天(质押,取消质押不受影响) 转质押一月可以操作7次 3.收益: 收益需要提取才能到可操作账户 进行质押,取消质押,转质押操作时自动提取收益 "},"cn/api/swagger-api.html":{"url":"cn/api/swagger-api.html","title":"API服务","keywords":"","body":"开通自己节点的对外api服务，需要修改数据目录（默认的数据目录 ~/.plugchain）里的 config/app.toml 的 enable,swagger ,修改为 true ############################################################################### ### API Configuration ### ############################################################################### [api] # Enable defines if the API server should be enabled. enable = true # Swagger defines if swagger documentation should automatically be registered. swagger = true "},"cn/api/txs.html":{"url":"cn/api/txs.html","title":"服务端操作","keywords":"","body":" 生成、签署和广播交易 本文档描述了如何生成（未签名）交易、对其进行签名（使用一个或多个密钥）并将其广播到网络。 服务端发起交易，以golang作为服务端语言开发: 在生成交易之前，需要创建一个“TxBuilder”的新实例。 由于 SDK 支持 Amino 和 Protobuf 事务，第一步是决定使用哪种编码方案。 所有后续步骤都保持不变，无论您使用的是 Amino 还是 Protobuf，因为“TxBuilder”抽象了编码机制。 在以下代码段中，我们将使用 Protobuf。 1. 初始化需要的 txBuilder 和 codec import ( \"github.com/oracleNetworkProtocol/plugchain/app\" ) func sendTx() error { // 选择您的编解码器：Amino 或 Protobuf encCfg := app.MakeTestEncodingConfig() // 创建一个新的 TxBuilder。 txBuilder := encCfg.TxConfig.NewTxBuilder() // --剪断-- } 2. 根据自己操作的不同功能，需要准备不同的数据，以下以转账为例，需要准备： 发送方地址 gx1s65azh0yj7n8yn4u0q449wt50eqr4qtyjzmhed 节点上name是 walletName 发起者地址的私钥 可以通过 plugchaind keys export walletName --unarmored-hex --unsafe 得到 发起者地址的 accountNumber 和 Sequence 可以通过查询 节点ip:1317/cosmos/auth/v1beta1/accounts/{address} 接收者地址 import ( \"encoding/hex\" sdk \"github.com/cosmos/cosmos-sdk/types\" \"github.com/cosmos/cosmos-sdk/crypto/keys/secp256k1\" ) chainID := \"plugchain\" addr1, _ := sdk.AccAddressFromBech32(\"gx1s65azh0yj7n8yn4u0q449wt50eqr4qtyjzmhed\") addr2, _ := sdk.AccAddressFromBech32(\"gx1d0ug2e7ehy6prw6msrtqwt55mydmxdsx4em9ds\") priv := \"55e2413b83e590944c6a4bcb443374c60bba847fc079788bd97ea455cb555bf0\" privB, _ := hex.DecodeString(priv) priv1 := secp256k1.PrivKey{Key: privB} accountSeq := uint64(1) acountNumber := uint64(0) // TxBuilder 定义了一个应用程序定义的具体事务的接口 // 类型必须实现。 即，它必须能够设置消息，生成 // 签名，并提供规范字节进行签名。 交易必须 // 也知道如何编码自己。 TxBuilder interface { GetTx() signing.Tx SetMsgs(msgs ...sdk.Msg) error SetSignatures(signatures ...signingtypes.SignatureV2) error SetMemo(memo string) SetFeeAmount(amount sdk.Coins) SetGasLimit(limit uint64) SetTimeoutHeight(height uint64) } import ( banktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\" ) func sendTx() error { // --剪断-- //发送一笔转账: //地址addr1 到 addr2 //交易需要addr1 签名 msg1 := banktypes.NewMsgSend(addr1, addr2, types.NewCoins(types.NewInt64Coin(\"plug\", 5000000))) err := txBuilder.SetMsgs(msg1, msg2) if err != nil { return err } txBuilder.SetGasLimit(200000) // txBuilder.SetFeeAmount(...) // txBuilder.SetMemo(...) // txBuilder.SetTimeoutHeight(...) } 此时，TxBuilder 的底层交易已准备好进行签名。 3. 签署交易 我们选择我们的编码配置来使用 Protobuf，默认情况下它将使用SIGN_MODE_DIRECT。 根据 ADR-020，每个签名者需要 签署所有其他签名者的SignerInfo。 这意味着我们需要依次执行两个步骤： 对于每个签名者，在TxBuilder中填充签名者的SignerInfo， 一旦所有SignerInfos 被填充，对于每个签名者，签署SignDoc（要签名的有效负载）。 在当前的 TxBuilder 的 API 中，这两个步骤都使用相同的方法完成：SetSignatures()。 当前的 API 要求我们首先执行一轮 SetSignatures() 带有空签名，仅填充 SignerInfos，以及第二轮 SetSignatures() 以实际签署正确的有效负载。 import ( cryptotypes \"github.com/cosmos/cosmos-sdk/crypto/types\" \"github.com/cosmos/cosmos-sdk/types/tx/signing\" xauthsigning \"github.com/cosmos/cosmos-sdk/x/auth/signing\" ) func sendTx() error { // --剪断-- //第一轮：我们收集所有签名者信息。 我们使用“设置空签名”技巧来做到这一点 sign := signing.SignatureV2{ PubKey: priv1.PubKey(), Data: &signing.SingleSignatureData{ SignMode: encCfg.TxConfig.SignModeHandler().DefaultMode(), Signature: nil, }, Sequence: accountSeq, } err = txBuilder.SetSignatures(sign) if err != nil { panic(err) } //第二轮： 设置所有签名者信息，因此每个签名者都可以签名。 sign = signing.SignatureV2{} signerD := xauthsigning.SignerData{ ChainID: chainID, AccountNumber: acountNumber, Sequence: accountSeq, } sign, err = cliTx.SignWithPrivKey( encCfg.TxConfig.SignModeHandler().DefaultMode(), signerD, txBuilder, cryptotypes.PrivKey(&priv1), encCfg.TxConfig, accountSeq) if err != nil { panic(err) } err = txBuilder.SetSignatures(sign) if err != nil { panic(err) } } TxBuilder现在已正确填充。 要打印它，您可以使用初始编码配置 encCfg 中的 TxConfig 接口： func sendTx() error { // --剪断-- // 生成的 Protobuf 编码字节。 txBytes, err := encCfg.TxConfig.TxEncoder()(txBuilder.GetTx()) if err != nil { return err } } 广播交易 广播交易的首选方式是使用 gRPC，但也可以使用 REST（通过 gRPC-gateway）或 Tendermint RPC。 import ( \"context\" \"fmt\" \"google.golang.org/grpc\" \"github.com/cosmos/cosmos-sdk/types/tx\" ) func sendTx() error { // --剪断-- // 创建一个grpc服务 grpcConn := grpc.Dial( \"127.0.0.1:9090\", // 你的 gRPC 服务器地址。 grpc.WithInsecure(), // SDK 不支持任何传输安全机制。 ) defer grpcConn.Close() // 通过 gRPC 广播 tx。 我们为 Protobuf Tx 服务创建了一个新客户端。 txClient := tx.NewServiceClient(grpcConn) //然后我们在这个客户端上调用 BroadcastTx 方法。 grpcRes, err := txClient.BroadcastTx( context.Background(), &tx.BroadcastTxRequest{ Mode: tx.BroadcastMode_BROADCAST_MODE_SYNC, TxBytes: txBytes, }, ) if err != nil { return err } fmt.Println(grpcRes.TxResponse.Code) // 如果 tx 成功，则应为 0 return nil } 使用REST API 广播交易 不能使用 REST API 生成或签署交易，只能广播。 使用 REST 端点（由 gRPC-gateway 提供服务）广播交易可以通过如下发送 POST 请求来完成，其中 txBytes 是签名交易的 protobuf 编码字节： 下文使用的NewTxBytes ,需要通过上面获取的 txBytes 执行以下操作 import ( \"fmt\" \"encoding/base64\" ) func sendTx() error { //--剪断-- // base64 encode the encoded tx bytes NewTxBytes := base64.StdEncoding.EncodeToString(txBytes) fmt.Println(NewTxBytes) } 然后通过下面方式广播： curl -X POST \\ -H \"Content-Type: application/json\" -d'{\"tx_bytes\":\"{{NewTxBytes}}\",\"mode\":\"BROADCAST_MODE_SYNC\"}' localhost:1317/cosmos/tx/v1beta1/txs 使用 CosmJS（JavaScript 和 TypeScript）操作 CosmJS 旨在用 JavaScript 构建可以嵌入 Web 应用程序的客户端库。 请参阅 https://github.com/oracleNetworkProtocol/cosmjs 了解更多信息。 "},"cn/api/proto-docs.html":{"url":"cn/api/proto-docs.html","title":"操作方法及其参数","keywords":"","body":" Protobuf Documentation Table of Contents cosmos/base/v1beta1/coin.proto Coin cosmos/bank/v1beta1/bank.proto Input Output cosmos/bank/v1beta1/tx.proto MsgMultiSend MsgSend cosmos/staking/v1beta1/tx.proto MsgBeginRedelegate MsgCreateValidator MsgDelegate MsgEditValidator MsgUndelegate cosmos/tx/v1beta1/tx.proto Tx TxBody cosmos/tx/v1beta1/service.proto BroadcastTxRequest BroadcastMode Service cosmos/crypto/ed25519/keys.proto PrivKey PubKey cosmos/crypto/secp256k1/keys.proto PrivKey PubKey Top cosmos/base/v1beta1/coin.proto Coin Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto. Field Type Label Description denom string amount string DecCoin DecCoin defines a token with a denomination and a decimal amount. NOTE: The amount field is an Dec which implements the custom method signatures required by gogoproto. Field Type Label Description denom string amount string Top cosmos/bank/v1beta1/bank.proto Input Input models transaction input. Field Type Label Description address string coins cosmos.base.v1beta1.Coin repeated Output Output models transaction outputs. Field Type Label Description address string coins cosmos.base.v1beta1.Coin repeated Top cosmos/base/query/v1beta1/pagination.proto PageRequest PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex: message SomeRequest { Foo some_parameter = 1; PageRequest pagination = 2; } Field Type Label Description key bytes key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set. offset uint64 offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set. limit uint64 limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app. count_total bool count_total is set to true to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set. PageResponse PageResponse is to be embedded in gRPC response messages where the corresponding request message has used PageRequest. message SomeResponse { repeated Bar results = 1; PageResponse page = 2; } Field Type Label Description next_key bytes next_key is the key to be passed to PageRequest.key to query the next page most efficiently total uint64 total is total number of results available if PageRequest.count_total was set, its value is undefined otherwise Top cosmos/bank/v1beta1/tx.proto MsgMultiSend MsgMultiSend represents an arbitrary multi-in, multi-out send message. Field Type Label Description inputs Input repeated outputs Output repeated MsgSend MsgSend represents a message to send coins from one account to another. Field Type Label Description from_address string to_address string amount cosmos.base.v1beta1.Coin repeated use import ( banktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\" ) func sendTx() error { // --剪断-- addr1, _ := sdk.AccAddressFromBech32(\"gx1s65azh0yj7n8yn4u0q449wt50eqr4qtyjzmhed\") addr2, _ := sdk.AccAddressFromBech32(\"gx1d0ug2e7ehy6prw6msrtqwt55mydmxdsx4em9ds\") msg1 := banktypes.NewMsgSend(addr1, addr2, types.NewCoins(types.NewInt64Coin(\"plug\", 5000000))) err := txBuilder.SetMsgs(msg1, msg2) if err != nil { return err } // txBuilder.SetGasLimit(200000) // txBuilder.SetFeeAmount(...) // txBuilder.SetMemo(...) // txBuilder.SetTimeoutHeight(...) } Top cosmos/staking/v1beta1/tx.proto MsgBeginRedelegate MsgBeginRedelegate defines a SDK message for performing a redelegation of coins from a delegator and source validator to a destination validator. Field Type Label Description delegator_address string validator_src_address string validator_dst_address string amount cosmos.base.v1beta1.Coin MsgCreateValidator MsgCreateValidator defines a SDK message for creating a new validator. Field Type Label Description description Description commission CommissionRates min_self_delegation string delegator_address string validator_address string pubkey google.protobuf.Any value cosmos.base.v1beta1.Coin use import ( stakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\" ) func sendTx() error { // --剪断-- msg1 := stakingtypes.NewMsgCreateValidator(...) err := txBuilder.SetMsgs(msg1, msg2) if err != nil { return err } // txBuilder.SetGasLimit(200000) // txBuilder.SetFeeAmount(...) // txBuilder.SetMemo(...) // txBuilder.SetTimeoutHeight(...) } Description Description defines a validator description. Field Type Label Description moniker string moniker defines a human-readable name for the validator. identity string identity defines an optional identity signature (ex. UPort or Keybase). website string website defines an optional website link. security_contact string security_contact defines an optional email for security contact. details string details define other optional details. MsgDelegate MsgDelegate defines a SDK message for performing a delegation of coins from a delegator to a validator. Field Type Label Description delegator_address string validator_address string amount cosmos.base.v1beta1.Coin use import ( stakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\" ) func sendTx() error { // --剪断-- msg1 := stakingtypes.NewMsgDelegate()(...) err := txBuilder.SetMsgs(msg1, msg2) if err != nil { return err } // txBuilder.SetGasLimit(200000) // txBuilder.SetFeeAmount(...) // txBuilder.SetMemo(...) // txBuilder.SetTimeoutHeight(...) } MsgEditValidator MsgEditValidator defines a SDK message for editing an existing validator. Field Type Label Description description Description validator_address string commission_rate string We pass a reference to the new commission rate and min self delegation as it's not mandatory to update. If not updated, the deserialized rate will be zero with no way to distinguish if an update was intended. REF: #2373 min_self_delegation string use import ( stakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\" ) func sendTx() error { // --剪断-- msg1 := stakingtypes.NewMsgEditValidator(...) err := txBuilder.SetMsgs(msg1, msg2) if err != nil { return err } // txBuilder.SetGasLimit(200000) // txBuilder.SetFeeAmount(...) // txBuilder.SetMemo(...) // txBuilder.SetTimeoutHeight(...) } MsgUndelegate MsgUndelegate defines a SDK message for performing an undelegation from a delegate and a validator. Field Type Label Description delegator_address string validator_address string amount cosmos.base.v1beta1.Coin use import ( stakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\" ) func sendTx() error { // --剪断-- msg1 := stakingtypes.NewMsgUndelegate(...) err := txBuilder.SetMsgs(msg1, msg2) if err != nil { return err } // txBuilder.SetGasLimit(200000) // txBuilder.SetFeeAmount(...) // txBuilder.SetMemo(...) // txBuilder.SetTimeoutHeight(...) } Top cosmos/tx/signing/v1beta1/signing.proto SignatureDescriptor SignatureDescriptor is a convenience type which represents the full data for a signature including the public key of the signer, signing modes and the signature itself. It is primarily used for coordinating signatures between clients. Field Type Label Description public_key google.protobuf.Any public_key is the public key of the signer data SignatureDescriptor.Data sequence uint64 sequence is the sequence of the account, which describes the number of committed transactions signed by a given address. It is used to prevent replay attacks. use import ( \"github.com/cosmos/cosmos-sdk/types/tx/signing\" \"github.com/oracleNetworkProtocol/plugchain/app\" ) func sendTx() error { // --剪断-- encCfg := app.MakeEncodingConfig() var pubkey string //执行操作的地址的公钥 var accountSeq uint64 //执行操作地址的sequence txBuilder := encCfg.TxConfig.NewTxBuilder() sign := signing.SignatureV2{ PubKey: pubkey, Data: &signing.SingleSignatureData{ SignMode: encCfg.TxConfig.SignModeHandler().DefaultMode(), Signature: nil, }, Sequence: accountSeq, } err = txBuilder.SetSignatures(sign) if err != nil { panic(err) } } SignMode SignMode represents a signing mode with its own security guarantees. Name Number Description SIGN_MODE_UNSPECIFIED 0 SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be rejected SIGN_MODE_DIRECT 1 SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is verified with raw bytes from Tx SIGN_MODE_TEXTUAL 2 SIGN_MODE_TEXTUAL is a future signing mode that will verify some human-readable textual representation on top of the binary representation from SIGN_MODE_DIRECT SIGN_MODE_LEGACY_AMINO_JSON 127 SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses Amino JSON and will be removed in the future Top cosmos/tx/v1beta1/tx.proto AuthInfo AuthInfo describes the fee and signer modes that are used to sign a transaction. Field Type Label Description signer_infos SignerInfo repeated signer_infos defines the signing modes for the required signers. The number and order of elements must match the required signers from TxBody's messages. The first element is the primary signer and the one which pays the fee. fee Fee Fee is the fee and gas limit for the transaction. The first signer is the primary signer and the one which pays the fee. The fee can be calculated based on the cost of evaluating the body and doing signature verification of the signers. This can be estimated via simulation. Fee Fee includes the amount of coins paid in fees and the maximum gas to be used by the transaction. The ratio yields an effective \"gasprice\", which must be above some miminum to be accepted into the mempool. Field Type Label Description amount cosmos.base.v1beta1.Coin repeated amount is the amount of coins to be paid as a fee gas_limit uint64 gas_limit is the maximum gas that can be used in transaction processing before an out of gas error occurs payer string if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees. the payer must be a tx signer (and thus have signed this field in AuthInfo). setting this field does not change the ordering of required signers for the transaction. granter string if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does not support fee grants, this will fail SignerInfo SignerInfo describes the public key and signing mode of a single top-level signer. Field Type Label Description public_key google.protobuf.Any public_key is the public key of the signer. It is optional for accounts that already exist in state. If unset, the verifier can use the required \\ signer address for this position and lookup the public key. mode_info ModeInfo mode_info describes the signing mode of the signer and is a nested structure to support nested multisig pubkey's sequence uint64 sequence is the sequence of the account, which describes the number of committed transactions signed by a given address. It is used to prevent replay attacks. Tx Tx is the standard type used for broadcasting transactions. Field Type Label Description body TxBody body is the processable content of the transaction auth_info AuthInfo auth_info is the authorization related content of the transaction, specifically signers, signer modes and fee signatures bytes repeated signatures is a list of signatures that matches the length and order of AuthInfo's signer_infos to allow connecting signature meta information like public key and signing mode by position. TxBody TxBody is the body of a transaction that all signers sign over. Field Type Label Description messages google.protobuf.Any repeated messages is a list of messages to be executed. The required signers of those messages define the number and order of elements in AuthInfo's signer_infos and Tx's signatures. Each required signer address is added to the list only the first time it occurs. By convention, the first required signer (usually from the first message) is referred to as the primary signer and pays the fee for the whole transaction. memo string memo is any arbitrary memo to be added to the transaction timeout_height uint64 timeout is the block height after which this transaction will not be processed by the chain extension_options google.protobuf.Any repeated extension_options are arbitrary options that can be added by chains when the default options are not sufficient. If any of these are present and can't be handled, the transaction will be rejected non_critical_extension_options google.protobuf.Any repeated extension_options are arbitrary options that can be added by chains when the default options are not sufficient. If any of these are present and can't be handled, they will be ignored Top cosmos/tx/v1beta1/service.proto BroadcastTxRequest BroadcastTxRequest is the request type for the Service.BroadcastTxRequest RPC method. Field Type Label Description tx_bytes bytes tx_bytes is the raw transaction. mode BroadcastMode use curl -X POST \\ -H \"Content-Type: application/json\" -d'{\"tx_bytes\":\"{{NewTxBytes}}\",\"mode\":\"BROADCAST_MODE_SYNC\"}' localhost:1317/cosmos/tx/v1beta1/txs BroadcastMode BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method. Name Number Description BROADCAST_MODE_UNSPECIFIED 0 zero-value for mode ordering BROADCAST_MODE_BLOCK 1 BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for the tx to be committed in a block. BROADCAST_MODE_SYNC 2 BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for a CheckTx execution response only. BROADCAST_MODE_ASYNC 3 BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns immediately. Top cosmos/crypto/ed25519/keys.proto PrivKey PrivKey defines a ed25519 private key. Field Type Label Description key bytes PubKey PubKey defines a ed25519 public key Key is the compressed form of the pubkey. The first byte depends is a 0x02 byte if the y-coordinate is the lexicographically largest of the two associated with the x-coordinate. Otherwise the first byte is a 0x03. This prefix is followed with the x-coordinate. Field Type Label Description key bytes Top cosmos/crypto/secp256k1/keys.proto PrivKey PrivKey defines a secp256k1 private key. Field Type Label Description key bytes PubKey PubKey defines a secp256k1 public key Key is the compressed form of the pubkey. The first byte depends is a 0x02 byte if the y-coordinate is the lexicographically largest of the two associated with the x-coordinate. Otherwise the first byte is a 0x03. This prefix is followed with the x-coordinate. Field Type Label Description key bytes Scalar Value Types .proto Type Notes C++ Java Python Go C# PHP Ruby double double double float float64 double float Float float float float float float32 float float Float int32 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required) int64 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required) uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required) sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required) sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required) fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required) sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum bool bool boolean boolean bool bool boolean TrueClass/FalseClass string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8) bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT) "},"cn/basic/genesis.html":{"url":"cn/basic/genesis.html","title":"创世文件genesis.json","keywords":"","body":"创世（Genesis）文件 本文档解释了 Plugchain 主网的 genesis 文件是如何构建的。 它还解释了如何为自己的plugchain testnet 创建一个 genesis 文件。 请注意，您可以通过运行以下命令为您自己的 testnet 生成默认的 genesis 文件： plugchaind init --chain-id genesis 文件存储在 ~/.plugchain/config/genesis.json. 什么是创世文件 genesis 文件是一个 JSON 文件，用于定义区块链的初始状态。 它可以看作是区块链的高度\"0\"。 高度为\"1\"的第一个块将引用 genesis 文件作为其父级。 genesis 文件中定义的状态包含所有必要的信息，如初始令牌分配、创建时间、默认参数等。 我们来分别描述这些信息。 Genesis 时间和链ID genesis_time定义在 genesis 文件的顶部。 它是一个\"UTC\"时间戳，指示区块链何时启动。 此时，创世记验证人应该上线并开始参与共识过程。 当超过2/3的生成验证人（通过投票权加权）在线时，区块链启动。 \"genesis_time\": \"2020-03-13T17:00:00.000000000Z\", chain_id是您的链的唯一标识符。 它有助于区分使用相同版本的软件的不同链。 \"chain_id\": \"plugchain-1\", 共识参数 接下来，创世文件定义共识参数。 共识参数覆盖与共识层相关的所有参数，plugchain 的共识层是 Tendermint。 我们来看看这些参数： block max_bytes: 每个块的最大字节数。 max_gas: 每个块的最大 gas 数量。 该区块中包含的每笔交易都会消耗一些 gas，包含在一个区块内的交易所使用的总 gas 不能超出。 evidence max_age: 证据（evidence）是一种证明，表明验证者在同一高度（同一轮）签署了两个不同的区块。 这是一种明显的恶意行为，会在状态机层受到惩罚。 max_age定义块的最大数量，在经过max_age块之后证据不再有效。 validator pub_key_types: 可被验证人接受的公钥类型 (例如ed25519, secp256k1, ...) ，目前仅支持ed25519。 \"consensus_params\": { \"block\": { \"max_bytes\": \"22020096\", \"max_gas\": \"-1\", \"time_iota_ms\": \"1000\" }, \"evidence\": { \"max_age_num_blocks\": \"100000\", \"max_age_duration\": \"172800000000000\", \"max_bytes\": \"1048576\" }, \"validator\": { \"pub_key_types\": [ \"ed25519\" ] }, \"version\": {} }, 应用程序状态 应用程序状态定义了状态机的初始状态。 创世账号 在本节中，定义了初始分配的 Token。 可以通过直接编辑 genesis 文件手动添加帐户，但也可以使用以下命令： // Example: plugchaind add-genesis-account plug1qs8tnw2t8l6amtzvdemnnsq9dzk0ag0z37gh3h 10000000plug plugchaind add-genesis-account 这个命令在 app_state.accounts 下创建一个条目。 \"accounts\": [ { \"address\": \"plug1qs8tnw2t8l6amtzvdemnnsq9dzk0ag0z37gh3h\", \"coins\": [ { \"denom\": \"plug\", \"amount\": \"10000000\" } ], \"sequence_number\": \"0\", \"account_number\": \"0\", \"original_vesting\": [ { \"denom\": \"plug\", \"amount\": \"26306000000\" } ], \"delegated_free\": null, \"delegated_vesting\": null, \"start_time\": \"0\", \"end_time\": \"10000\" } ] 让我们来分别解读这些参数： sequence_number: 此编号用于计算此帐户发送的交易数。 每次事务包含在块中时它都会递增，并用于防止重放攻击，初始值为\"0\"。 account_number: 帐户的唯一标识符，它在包含此帐户的首次被打包到块的交易中生成。 original_vesting: 锁仓（Vesting） 由plugchain原生支持。 您可以定义帐户需要锁仓 token 数量，这些 token 在一定时间之后才能流通。 锁仓中的 token 可用于委托。 默认值为\"null\"。 delegated_free: 在 vest 过期后可转让的委托 token 数量。在创世文件中，大部分情况是 null。 delegated_vesting: 锁仓中的 token 数量。在创世文件中，大部分情况是 null。 start_time: vesting 期开始区块高度。创世文件中，大部分情况是0。 end_time: vesting 期结束区块高度。如果没有 token 在 vesting 期，这个值是0。 银行（Bank） bank模块负责 token。default_send_enabled参数是\"转账\"是否在创世文件启用。 \"bank\": { \"params\": { \"send_enabled\": [], \"default_send_enabled\": true }, \"supply\": [], \"denom_metadata\": [] } 权益（Staking） staking模块处理状态机中的大多数 POS 逻辑。 此部分应如下所示： \"staking\": { \"params\": { \"unbonding_time\": \"1814400s\", \"max_validators\": 100, \"max_entries\": 7, \"historical_entries\": 10000, \"bond_denom\": \"plug\" }, \"last_total_power\": \"0\", \"last_validator_powers\": [], \"validators\": [], \"delegations\": [], \"unbonding_delegations\": [], \"redelegations\": [], \"exported\": false }, 让我们来分别解读这些参数： params unbonding_time: 以纳秒为单位的解绑延迟时间。 max_validators: 最大验证人节点数量。 max_entries: 每对验证人和委托人之间可进行解委托、重新委托的最大条目数。 bond_denom: 权益代币符号。 last_total_power: 总投票权重。在创世文件通常是0（除非创世文件使用了之前的状态）。 last_validator_powers: 最后一个区块的状态中每个验证人的投票权重。在创世文件中通常是 null（除非创世文件使用了之前的状态）。 validators: 最后一个区块中的验证人列表。在创世文件中通常是 null（除非创世文件使用了之前的状态）。 unbonding_delegations: 最后一个区块中的解绑委托列表。在创世文件中通常是 null（除非创世文件使用了之前的状态）。 redelegations: 最后一个区块中的重新委托列表。在创世文件中通常是 null（除非创世文件使用了之前的状态）。 exported: 创世文件是否是从之前的状态导出得到的。 挖矿（Mint） mint模块管理 token 供应的通胀逻辑。 创世文件中的mint部分如下所示： \"mint\": { \"minter\": { \"inflation\": \"0.130000000000000000\", \"annual_provisions\": \"0.000000000000000000\" }, \"params\": { \"mint_denom\": \"plug\", \"inflation_rate_change\": \"0.130000000000000000\", \"inflation_max\": \"0.200000000000000000\", \"inflation_min\": \"0.070000000000000000\", \"goal_bonded\": \"0.670000000000000000\", \"blocks_per_year\": \"6311520\" } }, 让我们来分别解读这些参数： minter inflation：总 token 供应量的年化通胀百分比，每周更新。值 \"0.070000000000000000\" 意味着目标是每年通货膨胀率为\"7％\"，每周重新计算一次。 annual_provisions: 每块重新计算。初始值是 0.000000000000000000。 params mint_denom: 增发权益代币面值，此处是 uatom。 inflation_rate_change: 通胀每年最大变化。 inflation_max: 最高通胀水平。 inflation_min: 最低通胀水平。 goal_bonded: 目标绑定量占总供应量百分比。如果委托 token 的百分比低于此目标，则通胀率会增加（在inflation_rate_change之后），直至达到inflation_max。 如果委托 token 的百分比高于此目标，则通胀率会下降（在inflation_rate_change之后），直至达到inflation_min。 blocks_per_year: 每年出块量估算。用于计算出块收益中权益 token 的通胀部分（称之为块供给）。 分配（Distribution） distribution模块处理每个块中发给验证人和委托人的挖矿及手续费的分配逻辑。 创世文件中的distribution部分如下所示： \"distribution\": { \"params\": { \"community_tax\": \"0.020000000000000000\", \"base_proposer_reward\": \"0.010000000000000000\", \"bonus_proposer_reward\": \"0.040000000000000000\", \"withdraw_addr_enabled\": true }, \"fee_pool\": { \"community_pool\": [] }, \"delegator_withdraw_infos\": [], \"previous_proposer\": \"\", \"outstanding_rewards\": [], \"validator_accumulated_commissions\": [], \"validator_historical_rewards\": [], \"validator_current_rewards\": [], \"delegator_starting_infos\": [], \"validator_slash_events\": [] }, 让我们来分别解读这些参数： fee_pool community_pool: 用于支付奖励的 token 放在公共池中，它通过治理提案分配。在创世文件中通常是 null。 params community_tax: 税率，即交易费和出块收益中需要放入公共池部分的百分比。 base_proposer_reward: 区块提议者在有效区块中收取的交易费用奖励的基础部分。 如果值为0.010000000000000000，则1％的费用将转给提议者。 bonus_proposer_reward: 如果区块提议者收集了 2/3 （该块有效的最小值）加权投票的预提交，则获得 base_proposer_reward 奖励。 如果区块提议者收集了100％加权投票的预提交，则奖励会再线性增加bonus_proposer_reward。 withdraw_addr_enabled: 如果是true，委托人可以设置不同的地址来取回他们的奖励。 如果要在创世时禁用转账，则要设置为false，因为它可以绕过转账限制。 delegator_withdraw_infos: 委托人收益地址列表。 如果没有从之前的状态导出，一般是null。 previous_proposer: 上一个块的提议者， 如果没有从之前的状态导出，则设置为\"\"。 outstanding_rewards: 未付（未提取）奖励。如果没有从之前的状态导出，设置为null。 validator_accumulated_commission: 未付（未提取）验证人佣金。如果没有从之前的状态导出，设置为null。 validator_historical_rewards: 验证人的历史奖励相关的信息，由distribution模块用于各种计算。 如果没有从之前的状态导出，设置为null。 validator_current_rewards: 验证人的当前奖励相关的信息，由distribution模块用于各种计算。 如果没有从之前的状态导出，设置为null。 delegator_starting_infos: Tracks the previous validator period, the delegation's amount of staking token, and the creation height (to check later on if any slashes have occurred). 跟踪先前的验证人时期，委托的 token 数量和创建高度（稍后检查是否发生了需要惩罚的事件）。 如果没有从之前的状态导出，设置为null。 validator_slash_events: Set of information related to the past slashing of validators. Set to null if genesis was not exported from previous state. 过往验证人惩罚事件相关的信息集。 如果没有从之前的状态导出，设置为null。 治理（Governance） gov模块处理所有与治理相关的事务。 gov部分的初始状态如下所示： \"gov\": { \"starting_proposal_id\": \"1\", \"deposits\": [], \"votes\": [], \"proposals\": [], \"deposit_params\": { \"min_deposit\": [ { \"denom\": \"plug\", \"amount\": \"10000000\" } ], \"max_deposit_period\": \"172800s\" }, \"voting_params\": { \"voting_period\": \"172800s\" }, \"tally_params\": { \"quorum\": \"0.334000000000000000\", \"threshold\": \"0.500000000000000000\", \"veto_threshold\": \"0.334000000000000000\" } }, 让我们来分别解读这些参数： starting_proposal_id: 此参数定义第一个提案的ID，每个提案都由唯一ID标识。 deposits: 每个提案 ID 的保证金列表。如果没有从之前的状态导出，设置为null。 votes: 每个提案 ID 的投票列表。 如果没有从之前的状态导出，设置为null。 proposals: 所有提案列表。如果没有从之前的状态导出，设置为null。 deposit_params min_deposit: 使提案进入投票期的最小抵押数量，如果提供了多种面值，满足其一即可。 max_deposit_period: 最长抵押等待时间（单位纳秒），之后就不能再进行抵押了。 voting_params voting_period: 投票期时长（单位纳秒）。 tally_params quorum: 提议生效所需的投票数占总抵押数的最小百分比。 threshold: 提议生效所需 YES 票占总投票数的最小百分比。 veto_threshold: 提议生效所需NO_WITH_VETO 票占总投票数的最大百分比. 惩罚（Slashing ） The slashing module handles the logic to slash delegators if their validator misbehave. The slashing section in genesis looks as follows: slashing模块处理对验证人行为不当的惩罚逻辑。 创世文件中的slashing部分如下： \"slashing\": { \"params\": { \"signed_blocks_window\": \"100\", \"min_signed_per_window\": \"0.500000000000000000\", \"downtime_jail_duration\": \"600s\", \"slash_fraction_double_sign\": \"0.050000000000000000\", \"slash_fraction_downtime\": \"0.010000000000000000\" }, \"signing_infos\": [], \"missed_blocks\": [] }, 让我们来分别解读这些参数： params signed_blocks_window: 用于检验验证人节点可用性的滑动窗口，（单位块）。 min_signed_per_window: 在滑动窗口中预提交的数量少于此值，认为验证人节点可用性差。 downtime_jail_duration: 验证人节点因可用性差被关监狱后，在监狱中被关的时间（纳秒）。 slash_fraction_double_sign: 验证人节点双签时，需缴纳罚金占总委托数量的百分比。 slash_fraction_downtime: 验证人节点可用性差时，需缴纳罚金占总委托数量的百分比。 signing_infos:slashing 模块所需的每个验证人节点的各种信息。如果没有从之前的状态导出，设置为{}。 missed_blocks: slashing 模块所需的与丢块相关的各种信息。如果没有从之前的状态导出，设置为{}。 创世交易（Genesis Transactions） 默认情况下，genesis文件不包含任何gentxs。 gentx是一种交易，在创世文件中的将accounts下的 token 委托给验证人节点，本质上就是在创世时创建验证人。 在genesis_time之后，一旦有超过 2/3 的验证人（加权投票）作为有效gentx的接收者上线，该链就会启动。 可以手动将gentx添加到genesis文件，或通过以下命令： plugchaind collect-gentxs 此命令将存储在~/.plugchain/config/gentx中的所有gentxs添加到genesis文件中。 "}}